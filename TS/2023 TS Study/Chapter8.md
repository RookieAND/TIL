# 📖 Introduction

# ✒️ 몽키 패치보다는 안전한 타입을 사용하자

### ✏️ 객체와 클래스에 임의의 속성을 추가할 수 있지만 위험하다.

```js
window.monkey = 'Tamarin';
document.human = 'Baik Gwangin';

// 만약 정규식 자체에 monkey라는 속성을 추가한다면..?
Regexp.prototype.monkey // 'Capuchin';
/123/.monkey // '/123/' 도 정규식이므로 'Capuchin' 이 담겨 있다;
```

- JS에서는 객체와 클래스에 임의의 속성을 자유롭게 추가할 수 있다. 심지어는 내장 기능의 프로토타입에도 속성 추가가 가능하다.
- 하지만 이 경우 Side Effect가 발생할 확률이 높다. 전혀 연관이 없는 곳에서도 다른 곳에서 추가한 속성이 들어올 수 있기 때문이다.
- 예를 들면 A 라이브러리에서 `window` 객체에 특정한 속성을 집어 넣었는데, 이를 B 라이브러리에서도 사용할 수 있는 문제가 그 예시다. (서로 분리된 로직임에도 전역 변수이기 때문에 의존성을 가지게 된다.)
- window 전역 객체에 임의의 속성을 추가한다면 해당 속성은 전역적으로 관리되고, 이를 사용할 경우 **의존성 문제**가 발생한다.

```ts
document.human = "Baik Gwangin"; // 오류, Document 속성에 human 속성이 없습니다.

(document as any).human = "Baik Gwangin"; // 오류는 나지 않지만, 이제 어떤 값이 오던 간에 타입 체커가 작동하지 않는다.
```

- 게다가 TS 에서는 특정 객체의 내장 속성을 알고 있을지라도, 이후에 임의로 추가한 속성에 대해서는 알 길이 없다.
- 이를 가장 빠르게 해결하는 방법은 **any** 키워드를 사용하는 것이지만, 타입 안정성을 해치기 때문에 비추천한다.

### ✏️ 보강과 사용자 정의 인터페이스

- 최선의 해결책은 추가된 데이터를 분리하는 것이지만, 만약 그럴 수 없는 경우 두 개의 방법이 존재한다.

```ts
interface MonkeyDocument {
  monkey: string;
}

(document as MonkeyDocument).human = "Baik Gwangin"; // 정상
```

- 따라서 특정 속성을 담은 인터페이스를 만들고, 이를 타입 단언으로 부여하는 방식이 바로 **보강 방식** 이다.
- 보강 방식은 any를 쓰는 것보다 타입이 안전하고, 타입 체커가 인지할 수 있기에 속성에 주석을 붙일 수 있으며 자동 완성도 가능하다.

```ts
export {};

declare global {
  interface Document {
    monkey: string; // string | undefined 로 해도 되지만, 매번 undefined가 아닌지를 Type Narrowing으로 검사해야 한다.
  }
}
```

- 모듈의 관점에서 의도한 바를 동작하게 하기 위해서는 global 선언을 해야 하지만, 해당 방식은 모듈 전체에 걸쳐 전역적으로 적용된다.
- 또한 런타임 환경에서 속성을 할당하면 실행 시점에서 보강을 적용할 방법이 없다. 따라서 어떤 객체가 **속성이 있고 없는지를 파악하기가 어렵다**.
- 이를 방지하기 위해 유니온 타입으로 `undefined` 를 붙여 보다 정확한 타입을 파악할 수는 있지만, 매번 타입을 좁혀야 하기 때문에 사용이 불편하다.

```ts
interface MonkeyDocument extends Document {
  monkey: string;
}

(document as MonkeyDocument).human = "Baik Gwangin"; // 정상
```

- 두 번째 방식은 사용자 정의 인터페이스를 선언하고, 타입 단언을 사용하는 것이다.
- `MonkeyDocument` 는 `Document` 를 확장하기에 타입 단언은 합당하며 안전하다.
- 또한 Document 타입 자체를 건드리지 않고 이를 확장하는 타입으로 선언했기 때문에 앞선 모듈 스코프 문제도 해결이 가능하다.

# ✒️ 타입 커버리지를 추적하여 타입 안전성 유지하기

### ✏️ any 타입이 존재하는 두 가지 경우

- 프로그램 내에 쓰이는 any 타입의 범주를 좁힌다 하더라도 명시적 any 타입은 **여전히 any 타입** 이다.
- 서드파티 타입 선언의 경우 `@types` 선언 파일로부터 전파되기 때문에 더 조심해야 한다. `noImplicitAny` 를 설정하고 any를 사용하자 않더라도 코드 전반에 영향을 미치기 때문이다.

```bash
npx type-coverage
npx type-coverage --detail
```

### ✏️ type-cover-age

- npm 내에서 `type-cover-age` 라이브러리를 활용하여 any를 추적할 수 있는데, 전체 타입 중 any가 아닌 타입의 비율을 산출해준다.
- 또한 타입 커버리지 정보를 수집하기 위해 `--detail` 플래그를 붙이면 any 타입이 나오는 곳을 전부 출력해준다.
- 하지만 결국에는 사용자가 작성된 프로그램의 타입이 얼마나 잘 선언되었는지를 꾸준히 추적하는 것이 중요하다. 그래야만 타입 안전성을 높힐 수 있다.

# ✒️ devDependencies에 typescript 와 @types 추가하기

### ✏️ dependencies, devDependencies, peerDependencies

- npm 에서는 세 가지 종류의 의존성을 구분해서 관리하며, 각각의 의존성은 모두 **packages.json** 파일 내에서 별도의 영역에 들어 있다.
- **dependencies** 란, 현재 프로젝트를 실행하는데 필수적인 라이브러리들의 목록이다. 만약 프로젝트를 npm에 릴리즈 하고 다른 사용자가 이를 설치한다면, 패키지의 dependencies 목록에 있는 라이브러리도 같이 설치된다. (전이 의존성)
- **devDependencies** 란, 프로젝트를 개발하고 테스트하는데 사용되나 런타임 과정에서는 필요 없는 라이브러리들의 목록이다. 대표적인 예로 RTL (React-Testing-Library) 가 그 예이다.
- **peerDependencies** 란, 런타임 환경에서 필요하긴 하나 의존성을 직접 관리하지 않는 라이브러리들이 포함된다.
- 단적인 예로 플러그인이 있는데, 플러그인은 **특정 버전의** host 패키지와 함께 사용하도록 설계되어 있다. 하지만 host 패키지에 의존하지는 않는다. 그럼에도 불구하고 의존성을 반드시 기술해주어야 중복된 의존성 트리가 발생하지 않는다.

### ✏️ 타입스크립트 관련 프로젝트에서 고려해야 할 점.

- 일반적으로 TS는 개발 도구이고 타입 정보는 런타임 과정에서 존재하지 않기 때문에 TS 관련 라이브러리는 **devDependencies** 에 넣는다.
- 모든 타입스크립트 프로젝트에서 고려해야 할 의존성 두 가지는 **타입스크립트 자체의 의존성** 과 **타입 의존성 (@types)** 이다.

### ✏️ 타입스크립트를 devDependencies 로 넣어야 하는 이유

- 타입스크립트를 시스템 레벨로 설치하게 되면 팀원들 모두가 동일한 버전을 설치할 것이라는 보장이 없으며, 프로젝트 셋업 시 별도의 설치가 필요하다는 단점이 있다.
- 따라서 devDependencies 에 타입스크립트를 포함시켜, `npm install` 명령어를 실행할 때 정확한 버전의 TS를 설치하도록 하는 것이 좋다.
- 대부분의 IDE와 빌드 툴은 devDependencies을 통해 설치된 TS 버전을 추적할 수 있고, `npx tsc` 를 통해 타입스크립트 컴파일러도 실행할 수 있다.

### ✏️ 타입 의존성을 고려해야 하는 이유

- 사용하는 라이브러리에 타입 선언이 포함되어 있지 않더라도, **DefinitelyTyped** 라이브러리에서 타입 정보를 얻을 수 있다.
- DefinitelyTyped 내의 타입 정의들은 npm 레지스트리의 `@type` 스코프에 공개되며 오직 타입 정보만을 포함한다.
- 따라서 원본 라이브러리 자체가 dependencies 에 있더라도 타입 정의는 devDependencies에 있어야 한다. 하지만 이 방식이 항상 유효한 것은 아니니 별도의 작업이 필요할 수 있다.

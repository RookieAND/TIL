# 📖 Introduction

> **브라우저가 어떻게 일하는지** 도 모르면서, 브라우저를 쓰려고 해?

# ✒️ Browser

### 1. 브라우저의 주요 기능.

- 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 (request) 이를 표시하는 것이다.
- 자원의 경우 보통 HTML 문서를 의미하지만, 이미지나 비디오, 문서 같은 바이너리 데이터일 수도 있다.
- 자원의 주소는 URL에 의해 정해진다. REST 아키텍쳐에서 나오는 자원의 식별자를 URL로 하기 때문이다.
- 브라우저는 W3C에서 표준화한 HTML과 CSS 명세에 따라 이를 파싱하여 렌더링을 진행한다.

### 2. 브라우저의 기본 구조

1. 사용자 인터페이스
   - 주소 표시줄, 이전 / 다음 버튼, 북마크 메뉴 등 요청한 페이지를 제외한 나머지 UI를 의미.
2. 브라우저 엔진
   - 사용자 인터페이스 (UI) 와 렌더링 엔진 사이의 동작을 제어한다.
3. 렌더링 엔진
   - 사용자가 요청한 컨텐츠를 브라우저 화면에 나타내게 해주는 기능을 함.
   - HTML 파일을 요청했다면 HTML과 CSS를 파싱하여 렌더 트리를 만들고, 이를 기반으로 렌더링을 진행함.
   - Chrome의 Webkit, Mozilla 의 Gecko 엔진이 대표적이다.
4. 통신
   - HTTP, FTP 같은 표준 프로토콜을 사용한 네트워크 호출에 사용된다.
5. UI 백엔드 : 일반적으로 창이나 콤보 박스 같은 기본적인 위젯을 그리기 위해 쓰임.
6. JS 인터프리터
   - JS 코드를 파싱하고 바이트 코드로 변환하여 실행 가능하도록 하는 인터프리터
   - Chrome의 V8 엔진이 가장 대중적으로 쓰이는 엔진이다.
7. 자료 저장소
   - 로컬 스토리지, 쿠키, IndexedDB 같은 저장 메커니즘을 지원하는 저장소.
   - 브라우저가 데이터를 저장해야 할 필요가 있을 경우 사용하는 지속성 레이어.

# ✒️ Rendering Engine

### 1. 렌더링 엔진은 어떻게 동작하는가?

- Chrome에서 쓰이는 Webkit 렌더링 엔진을 기준으로 작성하였다.
- 위 과정은 1 ~ 4번까지 점진적으로 진행된다.
- 단, 사용자 경험을 위해 모든 HTML을 파싱하지 않고 일부에 대한 Layout, Paint 작업을 먼저 시행할 수 있다.
- 이러한 일련의 과정을 **CRP(Critical Rendering Path)** 이라고 부른다.

1. 서버로부터 받은 HTML을 파싱하여 DOM, CSSOM 트리를 생성한다 (Parsing)

   - 렌더링 엔진은 HTML 문서를 파싱하고, 컨텐츠 트리 내부에서 태그를 DOM 노드로 변환한다.
   - HTML 내에 CSS가 포함되었다면, 이 또한 CSSOM으로 변환하여 트리를 구성한다.
   - Link 태그를 만나 CSS 요청이 발생했을 경우, 별도의 요청을 보내 받은 CSS를 파싱한다.
   - CSS를 파싱하면 HTML 파싱 작업은 잠시 중단되었다가, CSS 파싱 작업이 끝나면 이를 재개한다.
   - `script` 태그를 만나 외부로부터 번들링된 JS 파일을 받아야 할 경우, 파싱 작업은 중단된다.
   - JS는 parser 의 작업을 막는 리소스지만, `defer` 속성과 `async` 속성에 따라 차이점이 발생한다.

2. 두 트리를 매칭시켜 화면에 보여줄 요소들에 대한 렌더 트리를 생성한다. (Attachment)

   - DOM 트리와 시각 정보가 담긴 CSSOM 트리를 매칭시켜 실제 화면에 그려질 렌더 트리를 생성한다.
   - 렌더 트리는 색상, 또는 면적과 같은 **시각적 속상이 있는** 요소들만 포함하여, 정해진 순서대로 화면에 표시된다.
   - `visibility: hidden`, `opacity : 0` 의 경우에는 화면 상에서 보여지지 않을 뿐 실제로 요소가 존재하므로 트리에 포함시킨다.
   - `display: none` 의 경우 실제로 요소를 화면에서 제외시키기 때문에 렌더 트리 구성에서 제외된다.
     - `meta`, `script`, `head` 태그와 같이 사용자에게 보이지 않아도 되는 노드는 트리 구성에서 제외된다.

3. 렌더 트리의 요소를 순회하며 각 요소들을 화면에 어떻게 배치시킬지 정한다. (Layout)

   - 루트 노드부터 순회하며 각 노드들의 정확한 크기와 위치를 계산하여 반영한다.
   - `%` 이나 `rem`, `vh` 같은 단위로 설정되었다면, 이를 정확한 픽셀 값으로 변환시킨다.

4. 배치가 완료되었다면, 트리의 각 노드들을 화면 상의 실제 픽셀로 변환시킨다. (Paint)

   - 계산된 값을 활용하여 렌더 트리의 각 노드를 실제 화면상의 픽셀들로 변환시킨다.
   - 픽셀로 변환된 값은 여러 개의 레이어로 관리되며, 스타일이 복잡할수록 Paint 과정에 소요되는 시간도 증가한다.
   - 해당 과정의 경우 UI 백엔드 파트에서 각 노드를 가로지르며 형상을 그려낸다.

### 2. async, defer 속성의 차이점에 대해 보자.

1. 공통점

   - 기본적으로 parser는 script 태그를 만나면 파싱 작업을 중단하고 다운로드를 진행한다.
   - 하지만 `defer`, `async` 속성의 경우 JS 파일의 다운로드와 파싱 작업을 병행하도록 한다.

2. 차이점

   - defer :
     - 문서 파싱과 JS 다운로드를 동시에 진행하지만, parser가 문서를 온전히 읽은 후에 스크립트를 실행한다.
     - DOM 요소를 조작해야 하거나, 스크립트 간의 의존성이 존재한다면 defer를 사용하자.
   - async
     - 문서 파싱과 JS 다운로드를 동시에 진행하고, 다운로드가 완료되는 즉시 스크립트를 실행한다.
     - 스크립트가 실행되는 동안 파싱 작업은 잠시 중단되며, 실행이 끝난 후에 문서 파싱 작업을 재개한다.
     - 스크립트가 실행되었으나 이를 참조할 DOM이 아직 파싱되지 않았다면 문제가 발생한다.
     - DOM을 조작하지 않고, 스크립트 간의 의존성이 없이 독자적으로 작동하는 경우에만 사용하자.

# ✒️ Reflow, Repaint

### 1. Reflow란 무엇인가?

- Layout 작업을 다시 진행하는 것을 `Reflow` 라고 부른다.
- 렌더 트리의 모든 요소에 대한 위치와 크기를 다시 계산해야 하기에 비용이 크다.
- 아래의 작업이 진행되었다면 브라우저에서 Reflow가 발생한다.
  - DOM 요소 추가, 제거 및 변경
  - CSS 스타일 추가, 제거 및 변경
  - 특정 엘리먼트에 클래스를 추가.
  - CSS 애니메이션과 트랜지션, 애니메이션 내의 모든 프레임에서 발생.
  - 엘리먼트의 크기에 대한 offsetWidth와 offsetHeight 속성을 읽었을 경우.
  - 유저 인터렉션에 의한 Hover 효과, 필드에 텍스트 입력, 창 크기 조정, 글꼴 전환 등.

### 2. Repaint란 무엇인가?

- Paint 작업을 다시 진행하는 것을 `Repaint` 라고 한다.
- 변경된 시각적 요소를 적용하여 Paint 작업만 진행하므로 비용이 상대적으로 적다.
- 아래의 작업이 진행되었다면 브라우저에서 Repaint가 발생한다.
  - 가시성과 관련된 CSS 스타일 요소가 변경될 경우 (visibility, opacity)
  - Reflow 가 호출된 직후에 Repaint가 진행된다. Layout 작업 후에는 Paint 작업이 무조건 진행되기 때문이다.

### 2. 최신 브라우저에서 추가된 작업들

#### Paint Layer는 뭘까?

- 브라우저에서는 렌더 트리를 이루는 각각의 Render Object들을 화면에 보여주기 위해 이를 레이어 형태로 가공한다.
- 이를 바로 **Paint Layer** 라고 하며, 동일한 좌표 공간을 가지는 요소들의 경우 동일한 Layer에 속하게 된다.
- 기존의 Layer에만 국한되지 않고, 필요한 경우 새로운 Layer를 생성하여 이를 여러 개의 층으로 쌓을 수 있음.
  -

1. Update Layer Tree : 렌더 트리의 결과물 중에서, 실제 렌더링에 사용될 부분을 레이어로 만들어주는 과정이다.

   - Render 객체는 보다 효율적으로 화면에 요소들을 보여주기 위해 레이어 형태로 구성됨. 이것이 바로 Paint Layer.
   - 일반적으로 동일한 좌표 공간을 가지는 요소들은 같은 Paint Layer에 속하게 됨.
   - 이 말인 즉, 같은 Render Object 끼리라도 하나의 Layer에 묶이지 않는다는 의미.
   - 하지만 몇 가지 조건에 의거하여 추가적인 Layer를 생성하면 내부에 요소들을 그릴 수 있음.
     - Root Element인 경우
     - 명시적인 position 속성 값을 가지고 있는 경우.
     - opacity가 1 미만인 경우
   - GPU가 처리해야 하는 요소들의 경우 Graphic Layer를 생성하여 각 요소를 묶은 후 처리함.
     - video, canvas 태그를 사용하는 경우
     - 3D transform 속성을 사용하는 경우.

2. Composite : 생성된 레이어들을 하나의 비트맵으로 합성하는 과정이다.

# ✒️ Parsing

### 1. Parsing이란 무엇인가?

- 문서 파싱이란 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다.
- 파싱을 통해 변환된 결과는 문서 구조를 나타내는 트리이고, 보통 Parsing Tree, Syntax Tree 라고 한다.

### 2. Parsing 작업은 어떻게 진행되는가?

- 문서 파싱은 브라우저가 문서를 이해하고 사용할 수 있는 구조로 변환하는 과정을 의미한다.
- HTML 문서의 파싱 결과는 DOM 트리로서, 문서의 구조를 나타내는 노드 트리로 변환된다.

#### 2-1. Parsing의 문법은 어떻게 구성되었나?

- 파싱은 문서에 작성된 언어의 형식 혹은 규칙을 따른다.
- 즉 파싱할 수 있는 모든 형식은 일련의 규칙과 정해진 용어를 따라야 한다.
- 인간의 언어의 경우 정해진 형식과 규칙이 없기에 기계적으로 파싱을 진행할 수 없다.

#### 2-2. 일반적으로 Parsing은 어떻게 진행되는가?

1. 어휘 분석 (Lexical Analyzer, Scanner)

   - 주어진 자료를 유효한 토큰으로 분해하는 과정.
   - 토큰은 유효하게 구성된 단위의 집합체이다.
   - 공백과 줄 바꿈 같은 의미 없는 문자의 경우 제거한다.

2. 구문 분석 (Syntax Analyzer, Parser)

   - 해당 언어의 구문 규칙을 적용하는 과정
   - 어휘 분석을 통해 나온 새 토큰이 구문 규칙과 일치하는지 확인.
   - 규칙에 맞다면 노드가 파싱 트리에 추가되며, 파서는 다음 토큰을 요청함.
   - 규칙에 맞지 않다면 파서는 해당 토큰을 내부적으로 저장하고 다음 토큰을 요청함.
   - 해당 토큰과 일치하는 규칙이 발견되지 않았다면 예외 처리, 구문 오류라는 것을 내포함.

3. 변환

   - 어휘 / 구문 분석을 통해 생성된 파싱 트리는 최종 결과물이 아니다.
   - 소스 코드를 바이트 코드로 만드는 컴파일러의 경우 트리를 기계 코드로 반환한다.

### 3. HTML Parsing이 다른 Parsing과 다른 점.

    - HTML의 경우 일반적인 Parser를 적용할 수 없다.
    - 왜냐면 HTML 언어는 실수에 관대하다. 잘못된 태그 문법을 사용하더라도 오류를 내뿜지 않는다.
    - 설령 인계 받은 HTML 이 잘못 작성되었더라도 브라우저에서는 이를 지적하려 하지 않는다.
    - script 태그 내의 JS 코드 중 `document.write` 와 같은 구문은 새로운 토큰을 추가하기에, 이 과정에서 파싱이 수정될 수 있음.

> document.write 란?

- HTML 문서 내에 인자로 받은 텍스트를 추가하는 함수다.
- 당연히 텍스트를 작성하기 위해서는 문서가 열려야 하기에, `document.open` 함수가 선행적으로 실행된다.
- 파싱 과정에서 위 함수가 실행될 경우 HTML에 텍스트가 추가되고, 이를 토큰화하여 새로운 토큰이 생성된다.
- 따라서 결과적으로 HTML 문서의 소스와 일치하지 않는 DOM이 생성되어 사용하는 것을 비추천한다.

#### 3-1. HTML에서 사용하는 Parsing 기법은 무엇인가?

1.  Tokenizer (토큰화)

    - 토큰화 (Tokenizer) 는 어휘 분석으로서의 기능을 하며, 입력된 문서를 토큰으로 파싱한다.
    - HTML 내에서 토큰은 `'시작 태그'`, `'종료 태그'`, `'속성 이름'`, `'속성 값'` 으로 나뉜다.
    - 토큰을 인지했다면 이를 파싱 트리 생성자로 넘기고, 다른 토큰을 확인하기 위해 다음 문자를 체크.

    - 초기 상태는 자료 상태 이며, `<` 문자를 만날 경우 태그 열림 상태로 변환된다.
    - a-z 까지의 문자를 만날 경우 **시작 태그 토큰**을 생성하고 상태는 태그 이름 상태로 변한다.
    - 하지만 그 전에 `/` 을 만났다면 **종료 태그 토큰**을 생성하고 태그 이름 상태로 변경된다.
    - `>` 문자를 만나게 될 경우 현재 토큰을 발행하고 상태를 다시 자료 상태로 변경시킨다.

2.  Building DOM Tree (트리 구축)

    - 파서가 생성된다면 처음에는 문서 객체가 생성된다.
    - 이후 트리 구축 진행 시 문서 최상단에 DOM 트리가 수정되며 요소가 추가된다.
    - 토큰화 단계에서 발행된 토큰을 받아 트리 생성자를 통해 각각의 노드를 생성시키는 과정을 거친다.
    - 만약 DOM 트리에 요소를 추가하지 않는다면, 해당 요소는 임시 버퍼 저장소인 스택에 저장된다.
    - 해당 스택의 경우 부정확한 태그들 간의 중첩이나 중료되지 않은 태그들을 교정시킨다.

```html
<html>
	<body>
		Hello world
	</body>
</html>
```

# 📖 Introduction

> **CSR? SSR?** 오늘 다시 한번 그게 뭔지 파혜쳐보자.

"React는 CSR 기반의 SPA를 구축하기 위한 프레임워크다." 라는 말을 정말 많이도 들었지만, 여태까지 필자는 이것들이 뭔 차이점이 있는지를 잘 알지 못했다. CSR이랑 SPA랑 결국 한 페이지에서 렌더링 되는 거니까 같은 의미가 아닐까라고만 생각했지, 정확하게 이것들이 무슨 차이가 있는지를 근본적으로 알지 못했다.

최근 우연한 기회에 필자가 React 스터디를 주도하게 되었는데, 막상 껍질을 까고 보니 나는 정말 React를 왜 쓰는지 알고 있나 싶은 생각이 들었다. 따라서 이를 명확히 알기 위해 CSR, SSR, SPA, MPA 개념을 짚고 넘어가기로 결심하고, 위 개념들에 대한 나의 조사 결과를 정리하기로 했다.

# ✒️ Browser

### 1. 브라우저의 주요 기능.

-   브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 (request) 이를 표시하는 것이다.
-   자원의 경우 보통 HTML 문서를 의미하지만, 이미지나 비디오, 문서 같은 바이너리 데이터일 수도 있다.
-   자원의 주소는 URL에 의해 정해진다. REST 아키텍쳐에서 나오는 자원의 식별자를 URL로 하기 때문이다.
-   브라우저는 W3C에서 표준화한 HTML과 CSS 명세에 따라 이를 파싱하여 렌더링을 진행한다.

### 2. 브라우저의 기본 구조

1. 사용자 인터페이스
    - 주소 표시줄, 이전 / 다음 버튼, 북마크 메뉴 등 요청한 페이지를 제외한 나머지 UI를 의미.
2. 브라우저 엔진
    - 사용자 인터페이스 (UI) 와 렌더링 엔진 사이의 동작을 제어한다.
3. 렌더링 엔진
    - 사용자가 요청한 컨텐츠를 브라우저 화면에 나타내게 해주는 기능을 함.
    - HTML 파일을 요청했다면 HTML과 CSS를 파싱하여 렌더 트리를 만들고, 이를 기반으로 렌더링을 진행함.
    - Chrome의 Webkit, Mozilla 의 Gecko 엔진이 대표적이다.
4. 통신
    - HTTP, FTP 같은 표준 프로토콜을 사용한 네트워크 호출에 사용된다.
5. UI 백엔드 : 일반적으로 창이나 콤보 박스 같은 기본적인 위젯을 그리기 위해 쓰임.
6. JS 인터프리터
    - JS 코드를 파싱하고 바이트 코드로 변환하여 실행 가능하도록 하는 인터프리터
    - Chrome의 V8 엔진이 가장 대중적으로 쓰이는 엔진이다.
7. 자료 저장소
    - 로컬 스토리지, 쿠키, IndexedDB 같은 저장 메커니즘을 지원하는 저장소.
    - 브라우저가 데이터를 저장해야 할 필요가 있을 경우 사용하는 지속성 레이어.

# ✒️ Rendering Engine

### 1. 렌더링 엔진은 어떻게 동작하는가?

-   Chrome에서 쓰이는 Webkit 렌더링 엔진을 기준으로 작성하였다.
-   위 과정은 1 ~ 4번까지 점진적으로 진행된다.
-   단, 더 나은 사용자 경험을 위해 모든 HTML을 파싱하지 않고 일부에 대한 Layout, Paint 작업을 먼저 시행할 수 있다.

1. 서버로부터 받은 HTML을 파싱하여 DOM, CSSOM 트리를 생성한다 (Parsing)

    - HTML 내에 CSS가 포함되었다면, 이 또한 CSSOM으로 변환하여 트리를 구성한다.
    - Link 태그를 만나 CSS 요청이 발생했을 경우, 별도의 요청을 보내 받은 CSS를 파싱한다.
    - CSS를 파싱하면 HTML 파싱 작업은 잠시 중단되었다가, CSS 파싱 작업이 끝나면 이를 재개한다.
    - `script` 태그를 만나 외부로부터 번들링된 JS 파일을 받아야 할 경우, 파싱 작업은 중단된다.
    - JS는 parser 의 작업을 막는 리소스지만, `defer` 속성과 `async` 속성에 따라 차이점이 발생한다.

2. 두 트리를 매칭시켜 화면에 보여줄 요소들에 대한 렌더 트리를 생성한다. (Attachment)

    - DOM 트리와 CSSOM 트리를 매칭시켜 실제 화면에 그려질 렌더 트리를 생성한다.
    - `visibility: hidden`, `opacity : 0` 의 경우에는 화면 상에서 보여지지 않을 뿐 실제로 요소가 존재하므로 트리에 포함시킨다.
    - `display: none` 의 경우 실제로 요소를 화면에서 제외시키기 때문에 렌더 트리 구성에서 제외된다.

3. 렌더 트리의 요소를 순회하며 각 요소들을 화면에 어떻게 배치시킬지 정한다. (Layout)

    - 루트 노드부터 순회하며 각 노드들의 정확한 크기와 위치를 계산하여 반영한다.
    - `%` 이나 `rem`, `vh` 같은 단위로 설정되었다면, 이를 정확한 픽셀 값으로 변환시킨다.

4. 배치가 완료되었다면, 트리의 각 노드들을 화면 상의 실제 픽셀로 변환시킨다. (Paint)

    - 계산된 값을 활용하여 렌더 트리의 각 노드를 실제 화면상의 픽셀들로 변환시킨다.
    - 픽셀로 변환된 값은 여러 개의 레이어로 관리되며, 스타일이 복잡할수록 Paint 과정에 소요되는 시간도 증가한다.
    - 해당 과정의 경우 UI 백엔드 파트에서 각 노드를 가로지르며 형상을 그려낸다.

> script의 async, defer 속성에 대해 알아보자.

1. 공통점

    - 기본적으로 parser는 script 태그를 만나면 파싱 작업을 중단하고 다운로드를 진행한다.
    - 하지만 `defer`, `async` 속성의 경우 JS 파일의 다운로드와 파싱 작업을 병행하도록 한다.

2. 차이점

    - defer :
        - 문서 파싱과 JS 다운로드를 동시에 진행하지만, parser가 문서를 온전히 읽은 후에 스크립트를 실행한다.
        - DOM 요소를 조작해야 하거나, 스크립트 간의 의존성이 존재한다면 defer를 사용하자.
    - async
        - 문서 파싱과 JS 다운로드를 동시에 진행하고, 다운로드가 완료되는 즉시 스크립트를 실행한다.
        - 스크립트가 실행되는 동안 파싱 작업은 잠시 중단되며, 실행이 끝난 후에 문서 파싱 작업을 재개한다.
        - 스크립트가 실행되었으나 이를 참조할 DOM이 아직 파싱되지 않았다면 문제가 발생한다.
        - DOM을 조작하지 않고, 스크립트 간의 의존성이 없이 독자적으로 작동하는 경우에만 사용하자.

### 2. Parsing 작업은 어떻게 진행되는가?

-   문서 파싱은 브라우저가 문서를 이해하고 사용할 수 있는 구조로 변환하는 과정을 의미한다.
-   HTML 문서의 파싱 결과는 DOM 트리로서, 문서의 구조를 나타내는 노드 트리로 변환된다.

### 2-1. Parsing 의 대략적인 과정.

1.  Tokenizer (토큰 생성기)
    -   초기 상태는 자료 상태 이며, `<` 문자를 만날 경우 태그 열림 상태로 변환된다.
    -   a-z 까지의 문자를 만날 경우 시작 태그 토큰을 생성하고 상태는 태그 이름 상태로 변한다.
    -   `>` 문자를 만나게 될 경우 현재 토큰을 발행하고 상태를 다시 자료 상태로 변경시킨다.
    -   `/` 을 만날 종료 태그 토큰을 생성하고 태그 이름 상태로 변경된다.

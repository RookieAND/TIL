# 📖 Introduction

> windowing이 도대체 뭘까? 그냥 이런게 있다고만 들었는데 이번에 한번 알아볼까?

- 최근 사내에서 필자가 소속된 스쿼드 내의 팀원 두 분이 windowing 기법을 활용하여 성능을 최적화하고 이를 정리한 글을 읽게 되었다. 평소에도 windowing 기법이라는 게 있다는 것만 알고 있었는데, 이를 직접 적용하여 상당히 유의미한 성능 개선을 이루어내셨다는 결과를 보니 windowing 기법에 대해 더 알고 싶어졌다. 따라서 비록 사소하지만 해당 기법에 대한 공부를 진행하고, 가능하다면 직접 windowing 기법을 구현해보려고 한다.

# ✒️ 무한 스크롤 구현 시 발생하는 문제점

### ✏️ 무한 스크롤을 잘 써왔는데, 뭐가 문제라는 걸까

- 무한 스크롤의 경우, 일반적으로 사용자가 스크롤을 내려 요소의 최하단이 뷰포트에 잡히게 되면 새로운 데이터를 fetch 해오는 방식으로 구현한다. 이후 데이터를 기반으로 새로운 DOM 요소를 부착시킨다.
- 하지만 사용자가 계속해서 스크롤을 진행할 경우, 새롭게 데이터를 추가하고 DOM 요소를 추가하면서 한 페이지에 **과다하게 많은 DOM 요소가** 쌓인다.

### ✏️ 더 큰 문제점은 복잡한 컴포넌트들을 렌더링 하는 경우다

- 물론 innerText만 든 `div` 나 `p` 태그들만 추가된다면 육안으로 보일 정도의 심각한 지연이 발생하지 않는다. 하지만 **이미지**나 **연산할 것이 많은 컴포넌트**를 렌더링 해야 한다면 이야기가 달라진다.
- 각 요소 별로 이미지를 띄워야 하는 경우에는 모든 이미지 리소스를 서버로부터 요청해 각 요소에 적용하기 때문에 이 경우 매 렌더링 시마다 과도한 데이터를 요청하고 요소를 화면에 띄우기까지 긴 시간이 걸린다. 이는 결국 **사용자 경험 (UX)** 을 해치는 요인이 된다.
- 게다가 뷰포트에 보이지 않는 요소들까지 한꺼번에 추가해야 하니, 초기 렌더링 과정에서 불필요하게 많은 데이터를 가지고 와야 하는 문제도 생긴다.

# ✒️ 인터렉션과 관련된 성능을 측정하는 지표들

### ✏️ TBT (Total Blocking Time)

- **TBT (Total Blocking Time)** 이란, 메인 스레드가 사용자의 입력 응답을 막을 정도로 오래 차단되었을 때 FCP (First Contentful Paint) 와 TTI (Time to Interactive) 간의 총 시간을 측정한다.
- 한 마디로 화면 내에 요소들은 보이지만, 사용자가 브라우저의 화면과 상호작용할 수 없는 시간을 TTB 라고 한다.
- 화면 내의 상호작용하기 위해서는 메인 스레드를 통해 작업을 수행해야 하는데, 앞선 작업에서 지연 시간이 길어진다면 메인 스레드가 Blocked 상태이므로 사용자는 원활한 상호작용을 할 수 없게 된다.
- 보통 하나의 인터렉션을 수행하는데 걸린 시간이 **50ms** 이상인 경우 지연 시간이 긴 작업으로 간주되며, 사용자가 화면의 버벅임을 알아챌 수 있는 기준이기도 하다.
- 자세한 정보는 여기에 : https://web.dev/tbt/

### ✏️ INP (Interaction to Next Paint)

- **INP (Interaction to Next Paint)** 는 사용자가 페이지 내에서 수행한 모든 상호 작용의 대기 시간을 관찰하고, 이를 하나의 값으로 정리하여 보고한다.
- 보통 Lighthouse 에서는 페이지 내에 존재하는 모든 상호 작용을 진행하고 (클릭, 키보드 입력 등) 해당 인터렉션들에 대한 백분위수를 계산하여 가장 높은 백분위수를 가진 값을 선별한다. (즉, 지연 시간이 오래 걸리는 인터렉션을 선택한다는 의미)
- 만약 특정 인터렉션에 과도한 연산이 발생하여 메인 스레드가 Block 상태에 걸린다면, 즉 사용자가 페이지와 더 이상 상호작용할 수 없게 된다면 이는 좋지 못한 UX 이다.
- 일반적으로 **200ms** 이하의 INV를 가지면 좋은 UX를 제공하며, **500ms** 이상의 INV를 가지면 좋지 못한 UX를 제공하는 페이지이다.

- 자세한 정보는 여기에 : https://web.dev/inp/

# ✒️ windowing 기법

### ✏️ 그러면 그냥 화면에 보이는 요소만 렌더링 하자.

- 결국 하나의 페이지에 과도하게 많은 DOM 요소가 붙기 때문에 UX가 저하되는 것이니, 현재 뷰포트에 **보이는 요소들만** 렌더링해주면 문제가 쉽게 해결된다. 이를 **windowing 기법** 이라고 한다.
- React 에서도 한 페이지에 긴 목록을 렌더링 해야 하는 경우 windowing 기법을 사용하는 것을 적극 권장하고 있다. 관련 라이브러리는 `react-virtualize`, `react-window`, 마지막으로 최근 나온 tanstack 사의 `@tanstack/virtual` 이 있다.

### ✏️ 근데 화면에서 요소가 벗어나면 이를 삭제하면 되지 않나?

- 필자가 들었던 의문 중 하나가 바로 이것이었다. "그럼 Viewpoint를 관찰해서 렌더링할 DOM의 갯수를 일정하게 유지하면 되지 않나?" 하지만 DOM 요소를 직접 삭제하는 것도 결국 **DOM을 직접 조작하는 과정을 거쳐야 하기에** 느리다.
- 그렇다면 `display: none` 처리를 하면 될거라 생각했지만 결국 화면에 DOM 요소를 보이지 않게 처리할 뿐이지 **요소 자체는 남아있기에** DOM 요소의 갯수가 많아진다면 렌더링 비용도 그만큼 증가하게 된다. 특히 모바일의 경우에는 critical 하다.
- 따라서 상단의 두 방법은 근본적인 해결책으로서 부족하다고 판단했다.

### ✏️ 그러면 react-virtualized 는 어떻게 동작하는가?

- `react-virtualized` 는 기본적으로 스크롤바의 위치와 viewpoint 사이즈를 통해 어떤 요소가 viewpoint 혹은 사용자가 별도로 지정한 영역 내에서 보여지는지를 계산한다.
- 또한 `react-virtualized` 는 요소를 담을 컨테이너를 사용하며 `relative` 속성을 적용하는데, 컨테이너 내부에 들어할 각 요소들의 position과 높이를 적용하기 위해서이다.
- 결국 모든 요소를 페이지에 렌더링하지 않고, **화면에 보여줄 아이템들이 어떤 것인지를 계산하는 방식**으로 windowing 기법을 구현했다.

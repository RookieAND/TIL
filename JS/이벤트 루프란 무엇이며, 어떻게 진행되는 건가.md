# ✒️ JS Engine use Single Thread

### ✏️ JS는 단일 스레드 기반의 언어

-   JS는 단일 스레드 기반의 언어이다. 여러 개의 작업이 있더라도 하나의 작업만을 처리할 수 있다. 하지만 JS가 사용되는 환경에서는 여러 개의 작업이 동시에 처리되는 모습을 쉽게 볼 수 있다.
-   하지만 동기적 작업은 선행 작업의 시간이 오래 걸릴 경우 그 사이에 사용자는 작업이 완료될 때까지 기다려야 한다는 단점을 내포한다. 이를 타파하기 위해 쓰이는 것이 비동기 처리 방식이다.
-   브라우저나 Node.js 에서는 **이벤트 루프 기반의 비동기 방식으로 Non-Blocking I/O를 지원** 한다고 하는데, 이때 나오는 **이벤트 루프** 를 활용한 비동기 방식으로 JS는 동시성을 지원한다.
-   이를 통해 Node.js와 브라우저에서는 싱글 스레드 언어인 JS 에서도 **동시성 (Cocurrency)** 이 지원되도록 만들어준다.

### ✏️ 단일 스레드는 오직 JS 엔진에만 국한된다.

-   JS 엔진 자체는 단일 스레드지만 이를 구동하는 환경 (브라우저, Node.js) 의 경우에는 **여러 개의 스레드를 사용** 한다.
-   이러한 구동 환경과 단일 호출 스택을 사용하는 JS 엔진 간의 **상호 연동을 위해 쓰이는** 장치가 바로 **이벤트 루프** 인 것이다.

### ✏️ 비동기 관련 로직은 JS 엔진 외부에 있다.

-   JS 엔진인 V8 의 경우 단일 호출 스택 (Call Stack) 을 통해 순차적으로 들어온 요청을 스택에 담아 하나씩 처리한다.
-   허나 비동기 호출을 위해 쓰이는 `setTimeout` 이나 `XMLHttpRequest` 같은 Web API는 JS 엔진이 아닌 Web API에 정의되어 있다. 태스크 큐 같은 장치 또한 JS 엔진 외부에 구현되어 있다.
-   Node.js는 비동기 I/O를 지원하기 위해 C++ 기반의 `libuv` 라이브러리를 사용하며, 여기서 이벤트 루프를 제공한다.

### ✏️ Run-to-Completion

-   JS의 함수가 실행되는 방식을 보통 **Run to Completion** 방식이라 하는데, 이는 하나의 함수가 싱행되면 해당 함수가 종료되기 전까지 다른 작업이 중간에 실행되지 않음을 의미한다.
-   JS 엔진은 단일 호출 스택을 사용하며, 현재 스택에 쌓인 함수들이 모두 실행되어 스택에서 제거되기 전까지는 다른 함수가 실행될 수 없다.
-   JS 내 함수의 호출들은 **프레임** 스택을 형성한다고 말한다. 이는 함수가 실행될 시 콜 스택에 새로운 프레임이 추가되고 처리가 완료되면 없어지는 원리를 의미한다.

> Comment : 그래서 Paint 작업은 하나의 프레임, 즉 하나의 스택에서 처리된다고 말했던 거구나.

```javascript
function delay() {
    for (var i = 0; i < 100000; i++);
}

function foo() {
    delay();
    bar();
    console.log('foo!');
}

function bar() {
    delay();
    console.log('bar!');
}

function baz() {
    console.log('baz!');
}

// 결과 : bar!, foo!, baz! 순으로 출력된다.
setTimeout(baz, 10);
foo();
```

-   `setTimeout` 함수가 실행된다면 브라우저에게 타이머 이벤트를 요청한 후 콜 스택에서 제거된다.
-   이후 `foo` 함수가 실행되고, 내부의 `bar` 함수가 실행되며 차례로 스택에 추가되었다가 제거된다.
-   마지막으로 콜 스택이 비워졌다면 `baz` 함수가 스택에 즉시 추가되어 실행된다.

> setTimeout의 타이머가 항상 올바르게 작동한다는 보장이 없다.

-   결과적으로 상단의 코드에서 `baz` 는 10ms 보다 더 늦게 실행될 것이다. `setTimeout` 함수가 호출된 이후 실행된 `foo` 함수가 처리되기까지 오랜 시간이 걸린다면 콜 스택이 비워지지 않아 `baz` 함수가 실행될 수 없기 때문이다.

# ✒️ Event Loop

### ✏️ What is Event Loop?

-   브라우저는 다양한 작업을 순차적으로 처리해야 한다. 화면을 렌더링하거나 DOM의 이벤트를 관리하고, Promise와 setTimeout 같은 비동기 함수를 적절히 처리하는 일은 브라우저가 담당한다.
-   이런 작업들은 모두 Task라고 하며, 브라

-   브라우저에서 이벤트 루프란 Task Queue와 Call Stack을 모니터링하고 지속적으로 실행되는 하나의 프로세스이다.
-   Call Stack 이 비어있지 않으면 이벤트 루프는 스택이 빌 때까지 대기하다 Task Queue에서 콜백 함수를 꺼내와 Call Stack에 넣어 이를 실행시켜준다.

```javascript
// MDN 에서 제공한 이벤트 루프 관련 가상 코드
while (queue.waitForMessage()) {
    queue.processNextMessage();
}
```

-   위 코드에서 `waitForMessage()` 메소드는 현재 실행 중인 태스크가 없을 때 다음 태스크에 큐 내부의 작업이 추가될 때까지 대기하는 역할이다.
-   Task Queue 에서는 Queue의 첫번째 Task가 아니라 실행 가능한 첫 번째 Task를 가져온다. Queue에 속한 Task들 중에서 가장 오래된 Task를 가져온다.

### ✏️ Web API

-   Web API란 브라우저에게 제공하는 API 이며, 비동기 작업을 처리하기 위한 `setTimeout`, `Promise` 등과 같은 기능을 제공한다.
-   Call Stack 에서 실행된 비동기 함수들은 모두 Web API를 호출하며, 이후 Web API는 인계 받은 콜백 함수를 Task Queue 에 넣는다.

```javascript
console.log(1);
setTimeout(() => console.log(2));
console.log(3);
// 실행 결과 : 1, 3, 2 순으로 출력
```

-   상단의 코드는 아래와 같은 과정을 통해 최종적으로 출력된다.
    i. `console.log(1)` 함수가 Call Stack에 추가되고 이후 실행된다.
    ii. `setTimeout` 함수가 Call Stack에 추가되어 실행되고, 이는 Web API 를 호출시킨다.
    iii. 호출된 Web API는 인계 받은 콜백 함수를 Task Queue에 넣는다.
    iv. `console.log(3)` 함수가 Call Stack에 추가되고 이후 실행된다.
    v. 이벤트 루프에서 Call Stack이 비워졌음을 인지하고, Task Queue에 있던 Task를 가져온다.
    vi. 이후 Call Stack에 `console.log(2)` 함수가 추가되고 실행된다.

> Tick in Event Loop

-   Call Stack이 비면 이벤트 루프는 Task Queue에서 Task 를 가져와 스택에 추가한다. 이러한 과정의 반복을 이벤트 루프에서는 `tick` 이라고 한다.

### ✏️ (Macro) Task Queue

> Task queues are sets, not queues, because the event loop processing model grabs the first runnable task from the chosen queue, instead of dequeuing the first task.

-   `setTimeout` 이나 `setInterval` 같은 비동기 함수의 콜백 함수나 이벤트 핸들러 같은 Task가 보관되는 곳이다.
-   최종적으로 Call Stack에서 실행될 Task들이 모인 하나의 집합 (Set) 이며, 스택이 빌 경우 가장 먼저 들어온 실행 가능한 Task를 추가한다.
-   Task Queue는 크게 세 가지 Queue로 구분된다. ( Macro Task Queue, Micro Task Queue, A)

> Task Queue 에서 Task란 어떤 것들일까?

-   외부 스크립트 (`<script src="...">`)가 로딩될 때 이를 실행하는 작업.
-   `setTimeout` 이나 `setInterval` 같은 비동기 함수로부터 인계 받은 콜백 함수를 실행하는 작업.
-   사용자가 마우스를 움직일 때 `mousemove` 이벤트와 이벤트 핸들러를 실행하는 작업
-   HTML 문서를 parser로 파싱하여 토큰화 시키는 작업
-   Fetch, Ajax 같이 비동기적으로 외부로부터 리소스를 요청하는 작업
-   document 에 새로운 element 를 삽입하는 등의 DOM 조작 작업.

### ✏️ Micro Task Queue,

-   Micro Task 란, 기존의 Task에 영향을 받지 않고 비동기적으로 빠르게 수행되는 Task를 의미한다.
    -   `Promise`, `Object.observe`, `MutationObserver`, `process.nextTick` 이 이에 속한다.
-   현재 실행 중인 Task의 실행이 종료된 뒤 바로 다음에 일어날 Task들이 쌓이는 곳이다.
-   따라서 일반적인 구현으로는 각 Task가 끝나거나 Event Loop의 시작과 끝에서 체크된다. 이 과정을 표준 문서에서는 **Micro Task Checkpoint** 라고 정의하였다.

> Micro Task Check Point 는 무엇인가?

-

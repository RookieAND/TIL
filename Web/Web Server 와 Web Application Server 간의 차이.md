# ✒️ Web Server

- 웹 서버는 클라이언트로부터 들어온 HTTP 기반의 요청을 받아 HTML, CSS, JS 같은 정적인 컨텐츠를 전달해주는 역할을 한다.
- 만약 사용자로부터 동적인 리소스 요청이 들어왔을 경우에는 자체적으로 처리가 어렵기 때문에 이를 전담하는 Web Application Server 에 작업을 요청한다.
- Nginx, Apache Server 가 대표적인 Web Server 다.

# ✒️ Web Application Server

- 웹 어플리케이션 서버는 HTTP 기반으로 동작하며, 사용자의 데스크탑 혹은 장치에 애플리케이션을 실행하도록 하는 미들웨어이다.
- 웹 서버가 하는 기능 대부분을 WAS 에서도 처리할 수 있다. 즉 사용자가 정적인 컨텐츠를 WAS 에 요청해도 정상적인 응답이 가능하다.
- 웹 서버와의 다른 점은 서버의 자원을 활용하여 동적인 컨텐츠를 전달할 수 있다는 점이다. DB 혹은 서버 내 자원을 활용하여 요청 시마다 새로운 컨텐츠를 생성하여 사용자에게 전달할 수 있다.
- Apache Tomcat, Zeus, Resin 이 대표적인 Web Application Server 이다.

# ✒️ Difference between them

- 웹 서버의 경우 단순히 빌드 타임에 생성된 정적 컨텐츠만 요청에 맞게 전달할 뿐이지만, 웹 어플리케이션 서버의 경우 동적인 요청에 맞게 새로운 컨텐츠를 자체적으로 생성하여 전달한다는 것이 차이점이다.
- 하지만 웹 서버의 경우 정적인 리소스들만 전달해주면 되기 때문에 WAS 보다 비교적 안정적으로 빠르게 요청에 대한 작업을 수행할 수 있다. 반대로 웹 어플리케이션 서버의 경우 동적인 데이터를 위주로 처리하기 때문에 상대적으로 처리해야 할 작업이 더 많아 웹 서버보다는 요청에 대한 응답이 느리다.

# ✒️ Why We need Web Server

### 📒 서버 부하 방지
    - 웹 어플리케이션 서버가 웹 서버의 역할을 대체할 수 있음에도 이를 사용하는 이유는, **잦은 요청으로 인한 서버 부하를 방지하기 위함**이다.
    - WAS 의 경우 DB 조회 및 다양한 로직을 동적으로 처리해야 하는데, 여기에 정적 리소스까지 불러오는 작업까지 동시에 시행한다면 **하나의 서버에 과도한 작업이 집중**되므로 부하가 증가한다. 이는 속도 저하로 이어진다.
    - 따라서 정적인 컨텐츠를 전달하는 웹 서버를 앞에 두고, WAS 는 웹 서버가 처리하기 어려운 서버 사이드 로직을 수행하여 역할을 분담하여 서버의 부하를 줄일 수 있다.
### 📒 장애 극복 기능 탑재, 여러 대의 WAS 연결 가능.
    - 이러한 구조는 서비스의 규모가 커질수록 진가를 발휘한다. 사용자가 많은 대용량 WAS 의 경우 서버가 여러 대일수도 있는데, 일부 WAS 에 문제가 생긴다면 웹 서버에서는 문제가 발생한 WAS 의 접근을 막고 서버를 재시작한다. 이렇게 되면 사용자들은 WAS 에 **문제가 발생했는지를 모르고** 정상적으로 서비스를 이용할 수 있다.
    - 이러한 처리를 ‘장애 극복 기능’ 이라고 한다. 서버나 시스템, 네트워크 등에서 이상이 생길 경우 **예비 시스템으로 자동 전환**될 수 있도록 처리하는 기능을 웹 서버에서 자체적으로 구현하여 무중단 운영이 가능하다는 이점이 있다.
    - 작동이 중지된 WAS 를 대신하여 다른 WAS 를 사용하도록 유도하는 것을 **fail over** 라 하고, 작동 중지된 WAS 를 재시작하는 방식을 **fail back** 이라고 한다.
### 📒 다른 종류의 WAS 로 서비스 가능
    - Java, PHP, C# 등 다양한 언어로 작성된 WAS 를 **하나로 묶어서** 서비스할 수 있다. 웹 서버는 사용자의 요청에 맞게 올바른 WAS 에게 요청을 인계하면 되기 때문이다.
    - 하단에 기술한 CGI 방식으로도 동적인 처리가 가능하지만 WAS에 비해 한계가 명확하고 매 요청 시마다 서버를 재시작해야 한다는 점에서 좋지 못하다.
### 📒 서버를 물리적으로 분리함으로서 보안 강화
    - 웹 서버를 WAS 앞 단에 두어, 공격이 들어오더라도 WAS 단에서 처리하는 핵심 정보나 DB 까지 공격을 전파하지 못하게끔 웹 서버가 방파제 역할을 한다.
    - 또한 HTTPS 요청에 쓰이는 SSL 인증서에 대한 암호화 및 복호화 처리를 진행할 때도 웹 서버를 사용하기 때문에 더욱 좋다.

# ✒️ CGI (**Common Gateway Interface)**

### 📒 정의
- 서버와 애플리케이션 간에 데이터를 주고 받는 방식 (인터페이스) 을 CGI 라고 한다. 웹 서버의 경우 여러 언어로 만들어진 CGI 프로그램을 직접 호출하여 개별적인 프로세스를 생성한다.
    - C, PHP, Perl 의 경우에는 별도의 WAS 없이 웹 서버 만으로도 동적인 요청에 대한 처리가 가능한데, 이를 사전에 정의한 CGI 를 통해서 이루어진다.
    - 동적인 요청을 받은 웹 서버는 서버 내부에 정의된 **스크립트 파일**들이 저장된 폴더에 접근하고, 스크립트를 실행시켜 나온 결과를 클라이언트에게 보내는 형식이다.
### 📒 장점
    - 장점은 스크립트 작성이 간편하다는 것이다. 그리고 서버에 작성된 스크립트만 실행하면 되기 때문에 동작이 매우 가볍다.
### 📒 단점
    - 또한 CGI 의 경우 매 요청시마다 서버를 재시작 해야 하고, DB Connection 도 재시도 하기에 속도가 느리며 서버의 자원을 많이 잡아먹는다. 또한 페이지 로드 사이에 특정 데이터를 캐싱할 수도 없다 (서버가 꺼졌다가 다시 실행되기 때문)
    - CGI 방식의 근본적인 문제점은, 각각의 클라이언트 요청에 대해서 별도의 프로세스를 생성한다는 것이다. 즉 요청이 많아질수록 프로세스도 그에 비례하여 많아지고 점유 메모리량도 커져서 시스템에 많은 부하를 준다.
### 📒 개선안
    - 대안 중 하나는 별도의 애플리케이션을 스크립트 언어로 작성하고, 이를 처리하는 스크립트 엔진 (인터프리터) 를 웹 서버에 내장시켜 웹 서버 자체에서 별도의 프로세스를 생성하지 않고 자체적으로 이를 처리하는 방식이다. Apache Web Server 에서 쓰이는 `mod_perl`, `mod_php` 모듈이 대표적인 예다.
    - 다른 대안은 애플리케이션을 처리하는 프로세스를 미리 Daemon 으로 가동시킨 후에, 웹 서버의 요청을 Daemon 에서 처리하도록 하는 것이다. 이 경우에도 여러 프로세스를 생성할 필요 없이 사전에 가동시킨 Daemon 을 활용하기 때문에 프로세스 생성 부하를 줄이는 방식이다.